# This workflow builds a Java project, generates a categorized changelog,
# creates a release with jDeploy (using the changelog), and then notifies Discord.

name: Release CI

on:
  push:
    tags:
      - '*' # Triggers on any tag push, e.g., v1.0.0, 1.2.3

permissions:
  contents: write # Required for creating/editing GitHub releases and for jDeploy

jobs:
  build_and_release:
    name: Build, Release and Notify
    runs-on: ubuntu-latest
    outputs:
      release_body_set: ${{ steps.verify_release_body.outputs.body_is_set }}
      release_tag: ${{ github.ref_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required for conventional-changelog to access full commit history

      - name: Set up JDK 24
        uses: actions/setup-java@v4
        with:
          java-version: '24'
          distribution: 'temurin'
          cache: maven

      - name: Build with Maven
        run: mvn -B package --file pom.xml

      - name: Determine Previous SemVer Tag for Changelog
        id: previous_tag_detector
        shell: bash
        run: |
          echo "Current tag (GITHUB_REF_NAME): ${{ github.ref_name }}"
          CURRENT_TAG="${{ github.ref_name }}"
          
          # Fetch all tags to ensure local repo is up-to-date
          git fetch --tags --force
          
          echo "Listing all tags sorted by version (semver, most recent first):"
          # List all tags, filter for valid semver (X.Y.Z, optionally with -prerelease), sort them, reverse order
          git tag -l --sort=-v:refname | grep -E '^([0-9]+)\.([0-9]+)\.([0-9]+)((-[a-zA-Z0-9.-]+)?)$' > semver_tags_sorted.txt
          
          echo "--- Filtered SemVer Tags (sorted -v:refname) ---"
          cat semver_tags_sorted.txt
          echo "--- End Filtered SemVer Tags ---"

          PREVIOUS_TAG=""
          # Find the current tag in the sorted list of semver tags
          # and get the tag on the next line (which is the previous version due to reverse sort)
          if grep -q "^${CURRENT_TAG}$" semver_tags_sorted.txt; then
            PREVIOUS_TAG=$(grep -A1 -m1 "^${CURRENT_TAG}$" semver_tags_sorted.txt | tail -n1)
            if [ "${PREVIOUS_TAG}" == "${CURRENT_TAG}" ]; then
              # This happens if CURRENT_TAG is the last in the list (i.e., the oldest semver tag)
              PREVIOUS_TAG="" 
            fi
          else
            echo "Warning: Current tag ${CURRENT_TAG} does not appear to be a standard X.Y.Z semver tag or was not found in the filtered list."
            # As a robust fallback, try to get the immediate previous tag regardless of semver pattern, if different from current
            echo "Fallback: Trying 'git describe --tags --abbrev=0 ${CURRENT_TAG}^'"
            PREVIOUS_TAG_CANDIDATE=$(git describe --tags --abbrev=0 "${CURRENT_TAG}^" 2>/dev/null)
            if [ -n "${PREVIOUS_TAG_CANDIDATE}" ] && [ "${PREVIOUS_TAG_CANDIDATE}" != "${CURRENT_TAG}" ]; then
                PREVIOUS_TAG="${PREVIOUS_TAG_CANDIDATE}"
            else
                PREVIOUS_TAG="" 
            fi
          fi

          if [ -n "${PREVIOUS_TAG}" ]; then
            echo "Determined previous tag for changelog: ${PREVIOUS_TAG}"
            echo "::set-output name=previous_tag::${PREVIOUS_TAG}"
            echo "Commits between ${PREVIOUS_TAG} and ${CURRENT_TAG}:"
            git log --pretty=format:"%h %ai %s" "${PREVIOUS_TAG}".."${CURRENT_TAG}" || echo "Failed to list commits or range is empty."
          else
            echo "No distinct previous tag found. Changelog will be generated from the beginning of history up to ${CURRENT_TAG}."
            echo "::set-output name=previous_tag::" # Output empty string
            git log --pretty=format:"%h %ai %s" "${CURRENT_TAG}" -n 20 # List last 20 commits for context
          fi
          echo "-------------------------------------------------"

      - name: Generate categorized changelog to file
        id: changelog_generator
        uses: TriPSs/conventional-changelog-action@v5
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          output-file: "GENERATED_CHANGELOG.md" # Output to a file
          skip-version-file: "true"
          skip-commit: "true"
          skip-tag: "true"
          skip-git-pull: "true"
          skip-bump: "true"
          tag-prefix: ""
          release-count: 1 # Process only the current tag against the previous one
          # If previous_tag was empty, this will generate from the first commit up to the current tag.
          # If previous_tag is set, it should use that as the 'from' reference.
          # The action internally uses `git-semver-tags` which should respect the tag history.

      - name: Display Generated Changelog
        run: |
          echo "Contents of GENERATED_CHANGELOG.md:"
          cat GENERATED_CHANGELOG.md || echo "GENERATED_CHANGELOG.md is empty or not found."
          echo "-------------------------------------------------"

      - name: Build App Installer Bundles and Create/Update GitHub Release (jDeploy)
        id: jdeploy_release
        uses: shannah/jdeploy@master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          # jDeploy will append its standard notes after the content from release_notes_file.
          release_notes_file: GENERATED_CHANGELOG.md

      - name: Verify Release Body After jDeploy
        id: verify_release_body
        run: |
          echo "VERIFYING Release Body Content AFTER jDeploy has run:"
          VERIFIED_BODY=$(gh release view "${{ github.ref_name }}" --json body --template '{{.body}}')
          if [ -z "$(echo -e "${VERIFIED_BODY}" | tr -d '[:space:]')" ]; then
            echo "ERROR: Release body appears EMPTY or whitespace-only after jDeploy!"
            echo "Raw verified body: <<EOF"
            echo "${VERIFIED_BODY}"
            echo "EOF"
            echo "::set-output name=body_is_set::false"
          else
            echo "SUCCESS: Release body is NOT empty after jDeploy. Content:"
            echo "------------------- VERIFIED BODY START -------------------"
            echo -e "${VERIFIED_BODY}"
            echo "-------------------- VERIFIED BODY END --------------------"
            echo "::set-output name=body_is_set::true"
          fi
          echo "-------------------------------------------------"

      - name: Send GitHub Release to Discord
        # Only run if the release body was successfully set by jDeploy
        if: steps.verify_release_body.outputs.body_is_set == 'true'
        uses: SethCohen/github-releases-to-discord@v1.16.2
        with:
          webhook_url: ${{ secrets.WEBHOOK_URL }}
          color: "2105893"
          username: "Randomizer-CS2"
          avatar_url: "https://raw.githubusercontent.com/bsommerfeld/randomizer-cs2/refs/heads/master/.randomizer/design/logo/randomizer.png"
          content: "@everyone"
          footer_title: "Changelog"
          footer_icon_url: "https://raw.githubusercontent.com/bsommerfeld/randomizer-cs2/refs/heads/master/.randomizer/design/logo/randomizer.png"
          footer_timestamp: true
          max_description: '4096'
          reduce_headings: true
