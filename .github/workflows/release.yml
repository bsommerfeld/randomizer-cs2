# This workflow builds a Java project, generates a categorized changelog,
# creates a release with jDeploy, combines changelogs, and then notifies Discord.

name: Release CI

on:
  push:
    tags:
      - '*' # Triggers on any tag push, e.g., v1.0.0, 1.2.3

permissions:
  contents: write # Required for creating/editing GitHub releases and for jDeploy

jobs:
  build_and_release:
    name: Build, Release and Notify
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required for conventional-changelog to access full commit history

      - name: Set up JDK 24
        uses: actions/setup-java@v4
        with:
          java-version: '24'
          distribution: 'temurin'
          cache: maven

      - name: Build with Maven
        run: mvn -B package --file pom.xml

      - name: List relevant tags and commits for changelog diagnosis
        run: |
          echo "Current tag (GITHUB_REF_NAME): ${{ github.ref_name }}"
          echo "Listing all tags sorted by version (most recent first):"
          # List tags, sort them as versions (ignoring non-semver like 'jdeploy' for PREVIOUS_TAG determination)
          # and then get the one immediately preceding the current tag.
          git tag -l --sort=-v:refname > all_tags.txt
          echo "--- All Tags ---"
          cat all_tags.txt
          echo "--- End All Tags ---"

          CURRENT_TAG="${{ github.ref_name }}"
          # Attempt to find the previous semver tag
          PREVIOUS_TAG=$(grep -E "^[0-9]+\.[0-9]+\.[0-9]+$" all_tags.txt | grep -B1 -A0 "$CURRENT_TAG" | head -n1)
          
          if [ -z "${PREVIOUS_TAG}" ] || [ "${PREVIOUS_TAG}" == "${CURRENT_TAG}" ]; then
            echo "Could not automatically determine a distinct previous semver tag. Trying to find any immediate previous tag."
            # Fallback: try to get the immediate previous tag regardless of semver pattern, if different from current
            PREVIOUS_TAG_CANDIDATE=$(git describe --tags --abbrev=0 "${CURRENT_TAG}^" 2>/dev/null)
            if [ -n "${PREVIOUS_TAG_CANDIDATE}" ] && [ "${PREVIOUS_TAG_CANDIDATE}" != "${CURRENT_TAG}" ]; then
                PREVIOUS_TAG="${PREVIOUS_TAG_CANDIDATE}"
            else
                PREVIOUS_TAG="" # Explicitly set to empty if no suitable previous tag found
                echo "No suitable previous tag found before ${CURRENT_TAG}. Changelog might be from the beginning of history."
            fi
          fi

          if [ -n "${PREVIOUS_TAG}" ]; then
            echo "Determined previous tag for changelog range: ${PREVIOUS_TAG}"
            echo "Commits between ${PREVIOUS_TAG} and ${CURRENT_TAG} (inclusive of ${CURRENT_TAG}'s commit, exclusive of ${PREVIOUS_TAG}'s commit):"
            # The range PREVIOUS_TAG..CURRENT_TAG includes commits *after* PREVIOUS_TAG up to and including CURRENT_TAG
            git log --pretty=format:"%h %ai %s" "${PREVIOUS_TAG}".."${CURRENT_TAG}" || echo "Failed to list commits in range ${PREVIOUS_TAG}..${CURRENT_TAG}, or range is empty."
          else
            echo "No previous tag determined. Listing commits for current tag ${CURRENT_TAG} (might be all history if it's the first tag):"
            # This will list commits that are part of the current tag's history, potentially up to its creation if no other tags are specified.
            # For conventional-changelog, without a previous tag, it often goes to the first commit.
            git log --pretty=format:"%h %ai %s" "${CURRENT_TAG}" -n 20 # List last 20 commits for the current tag for context
          fi
          echo "-------------------------------------------------"


      - name: Generate categorized changelog
        id: changelog_generator
        uses: TriPSs/conventional-changelog-action@v5
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          output-file: "false"
          skip-version-file: "true"
          skip-commit: "true"
          skip-tag: "true"
          skip-git-pull: "true"
          skip-bump: "true"
          tag-prefix: ""
          release-count: 1 # Explicitly process only the current tag/release
          # preset: "conventionalcommits"

      - name: Build App Installer Bundles and Create/Update GitHub Release (jDeploy)
        id: jdeploy_release
        uses: shannah/jdeploy@master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Combine jDeploy notes with categorized changelog and Update GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_NAME: ${{ github.ref_name }}
          RAW_CATEGORIZED_CHANGELOG: ${{ steps.changelog_generator.outputs.changelog }}
        run: |
          echo "Raw categorized changelog output from step: <<EOF"
          echo "${RAW_CATEGORIZED_CHANGELOG}"
          echo "EOF"

          FINAL_CATEGORIZED_CHANGELOG="${RAW_CATEGORIZED_CHANGELOG}"
          # Check if the raw changelog is effectively empty (only whitespace or the generic header without list items)
          # The grep looks for typical list item markers (*) or section headers.
          if echo "${FINAL_CATEGORIZED_CHANGELOG}" | awk 'NF' | grep -qE "(\* |Features|Bug Fixes|Performance Improvements|BREAKING CHANGES)"; then
            echo "Using generated categorized changelog as it appears to have content."
          else
            echo "Categorized changelog is effectively empty or contains no standard sections. Using default message."
            FINAL_CATEGORIZED_CHANGELOG="### Changelog\n\nNo user-facing changes (e.g., features, fixes) noted in conventional commits for this release."
          fi
          
          echo "Attempting to update release for tag: ${TAG_NAME}"
          JDEPLOY_NOTES=$(gh release view "${TAG_NAME}" --json body --template '{{.body}}')

          if [ -z "${JDEPLOY_NOTES}" ]; then
            echo "jDeploy did not add any specific release notes, or the notes were empty."
            JDEPLOY_NOTES="*jDeploy artifacts and installers attached.*" 
          else
            echo "Successfully fetched jDeploy notes initially set by jDeploy."
          fi

          echo "-------------------------------------------------"
          echo "Final Categorized Changelog (for tag ${TAG_NAME}):"
          echo -e "${FINAL_CATEGORIZED_CHANGELOG}" # Use -e to render \n for multiline echo
          echo "-------------------------------------------------"
          echo "jDeploy Notes (fetched from GitHub release):"
          echo -e "${JDEPLOY_NOTES}" # Use -e to render \n for multiline echo
          echo "-------------------------------------------------"
          
          {
            echo -e "${FINAL_CATEGORIZED_CHANGELOG}"
            echo "" 
            echo "---" 
            echo "" 
            echo "**jDeploy Information & Artifacts:**"
            echo "" 
            echo -e "${JDEPLOY_NOTES}" 
          } > combined_release_notes.md

          echo "Combined notes to be uploaded to GitHub release (content of combined_release_notes.md):"
          cat combined_release_notes.md
          echo "-------------------------------------------------"

          gh release edit "${TAG_NAME}" --notes-file combined_release_notes.md
          
          echo "GitHub release notes for ${TAG_NAME} have been updated successfully (according to gh cli)."
          echo "Release URL: https://github.com/${GITHUB_REPOSITORY}/releases/tag/${TAG_NAME}"
          echo "-------------------------------------------------"
          echo "VERIFYING Release Body Content AFTER 'gh release edit':"
          VERIFIED_BODY_AFTER_EDIT=$(gh release view "${TAG_NAME}" --json body --template '{{.body}}')
          if [ -z "$(echo -e "${VERIFIED_BODY_AFTER_EDIT}" | tr -d '[:space:]')" ]; then # Check if empty after removing all whitespace
            echo "ERROR: Release body appears EMPTY or whitespace-only after 'gh release edit'!"
            echo "Raw verified body: <<EOF"
            echo "${VERIFIED_BODY_AFTER_EDIT}"
            echo "EOF"
          else
            echo "SUCCESS: Release body is NOT empty after 'gh release edit'. Content:"
            echo "------------------- VERIFIED BODY START -------------------"
            echo -e "${VERIFIED_BODY_AFTER_EDIT}"
            echo "-------------------- VERIFIED BODY END --------------------"
          fi
          echo "-------------------------------------------------"


      - name: Send GitHub Release to Discord
        if: success() # Ensures this runs only if previous steps were successful
        uses: SethCohen/github-releases-to-discord@v1.16.2
        with:
          webhook_url: ${{ secrets.WEBHOOK_URL }}
          color: "2105893"
          username: "Randomizer-CS2"
          avatar_url: "https://raw.githubusercontent.com/bsommerfeld/randomizer-cs2/refs/heads/master/.randomizer/design/logo/randomizer.png"
          content: "@everyone"
          footer_title: "Changelog"
          footer_icon_url: "https://raw.githubusercontent.com/bsommerfeld/randomizer-cs2/refs/heads/master/.randomizer/design/logo/randomizer.png"
          footer_timestamp: true
          max_description: '4096'
          reduce_headings: true
