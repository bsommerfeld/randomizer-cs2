# .github/workflows/release-main.yml
name: Release CI - Main (Manual Changelog & Integrated Discord)

on:
  push:
    tags:
      - '*' # Wird bei jedem Tag-Push ausgelöst

permissions:
  contents: write # Notwendig für Releases, Assets und das Committen der geleerten CHANGELOG.md
  # actions: write # Nicht mehr benötigt, da kein separater Workflow-Dispatch

jobs:
  build_release_and_notify:
    name: Build, Create Release, and Notify Discord
    runs-on: ubuntu-latest
    outputs:
      release_tag: ${{ github.ref_name }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # Token wird für den späteren Commit der geleerten CHANGELOG.md benötigt
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up JDK 24
        uses: actions/setup-java@v4
        with:
          java-version: '24'
          distribution: 'temurin'
          cache: maven

      - name: Build with Maven
        run: mvn -B package --file pom.xml

      - name: Prepare Changelog for jDeploy
        id: prep_changelog_for_jdeploy
        run: |
          CHANGELOG_SOURCE_FILE="CHANGELOG.md"
          JDEPLOY_NOTES_DIR=".jdeploy"
          JDEPLOY_NOTES_FILE="${JDEPLOY_NOTES_DIR}/release-notes.md"
          
          echo "Prüfe, ob ${CHANGELOG_SOURCE_FILE} existiert..."
          if [ ! -f "${CHANGELOG_SOURCE_FILE}" ]; then
            echo "FEHLER: ${CHANGELOG_SOURCE_FILE} nicht im Repository-Root gefunden!"
            echo "Erstelle eine Fallback-Datei für jDeploy: ${JDEPLOY_NOTES_FILE}"
            mkdir -p "${JDEPLOY_NOTES_DIR}"
            echo -e "### Changelog für ${{ github.ref_name }}\n\n*Keine ${CHANGELOG_SOURCE_FILE} im Repository gefunden. Release wurde ohne benutzerdefinierte Notizen erstellt.*" > "${JDEPLOY_NOTES_FILE}"
          else
            echo "Verwende ${CHANGELOG_SOURCE_FILE} für Release Notes und kopiere nach ${JDEPLOY_NOTES_FILE}."
            mkdir -p "${JDEPLOY_NOTES_DIR}"
            cp "${CHANGELOG_SOURCE_FILE}" "${JDEPLOY_NOTES_FILE}"
            echo "--- Inhalt von ${JDEPLOY_NOTES_FILE} (vor jDeploy) ---"
            cat "${JDEPLOY_NOTES_FILE}"
            echo "-------------------------------------------------------"
          fi

      - name: Build App Installer Bundles and Create/Update GitHub Release (jDeploy)
        id: jdeploy_release
        uses: shannah/jdeploy@master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          # jDeploy wird ./.jdeploy/release-notes.md als Basis für den Release-Body verwenden
          # und seine eigenen Installer-Informationen und Links darunter anfügen.

      - name: Wait for GitHub API to propagate release changes
        run: |
          echo "Warte 20 Sekunden, damit die von jDeploy erstellte/aktualisierte Release konsistent ist..."
          sleep 20

      - name: Attach original CHANGELOG.md as Release Asset
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_NAME: ${{ github.ref_name }}
        run: |
          if [ -f "CHANGELOG.md" ]; then
            echo "Versuche, CHANGELOG.md an Release ${TAG_NAME} anzuhängen..."
            gh release upload "${TAG_NAME}" CHANGELOG.md --clobber
            echo "CHANGELOG.md wurde als Asset an die Release ${TAG_NAME} angehängt."
          else
            echo "CHANGELOG.md nicht gefunden, konnte nicht als Asset angehängt werden."
          fi

      - name: Verify Final Release Body (for Discord)
        id: verify_final_release_body
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "VERIFIZIERE finalen Release Body Inhalt:"
          VERIFIED_BODY=$(gh release view "${{ github.ref_name }}" --json body -q .body || echo "VERIFIZIERUNGSFEHLER")
          
          if [[ "${VERIFIED_BODY}" == "VERIFIZIERUNGSFEHLER" ]] || [ -z "$(echo -e "${VERIFIED_BODY}" | tr -d '[:space:]')" ]; then
            echo "FEHLER: Finaler Release Body erscheint LEER oder nur Whitespace!"
            echo "Raw verifizierter Body: <<EOF"
            echo "${VERIFIED_BODY}"
            echo "EOF"
            echo "body_is_set=false" >> $GITHUB_OUTPUT
          else
            echo "ERFOLG: Finaler Release Body ist NICHT leer."
            echo "::set-output name=body_is_set::true"
            echo "------------------- VERIFIZIERTER FINALER BODY START -------------------"
            echo -e "${VERIFIED_BODY}"
            echo "-------------------- VERIFIZIERTER FINALER BODY ENDE --------------------"
          fi

      - name: Send GitHub Release to Discord
        if: steps.verify_final_release_body.outputs.body_is_set == 'true'
        uses: SethCohen/github-releases-to-discord@v1.16.2
        with:
          webhook_url: ${{ secrets.WEBHOOK_URL }}
          tag_name: ${{ github.ref_name }} # Die Action holt sich den Body basierend auf diesem Tag
          color: "2105893"
          username: "Randomizer-CS2"
          avatar_url: "https://raw.githubusercontent.com/bsommerfeld/randomizer-cs2/refs/heads/master/.randomizer/design/logo/randomizer.png"
          content: "@everyone"
          footer_title: "Release ${{ github.ref_name }}"
          footer_icon_url: "https://raw.githubusercontent.com/bsommerfeld/randomizer-cs2/refs/heads/master/.randomizer/design/logo/randomizer.png"
          footer_timestamp: true
          max_description: '4096'
          reduce_headings: true

      - name: Clear and Commit CHANGELOG.md for next release
        # Dieser Schritt läuft auch, wenn der Discord-Schritt fehlschlägt,
        # aber NACHDEM die Release erstellt und der Body (hoffentlich) verifiziert wurde.
        if: always()
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          TARGET_BRANCH=$(git branch -r --contains HEAD~0 | grep 'origin/' | sed 's|origin/||' | grep -v 'HEAD' | head -n 1)

          if [ -z "$TARGET_BRANCH" ]; then
            echo "Konnte den Zielbranch nicht automatisch bestimmen. Verwende 'main' als Fallback."
            TARGET_BRANCH="master"
          fi
          echo "Zielbranch für das Leeren des Changelogs: ${TARGET_BRANCH}"
          
          git checkout "${TARGET_BRANCH}"
          git pull origin "${TARGET_BRANCH}" --ff-only
          
          CHANGELOG_FILE_TO_CLEAR="CHANGELOG.md"
          if [ -f "${CHANGELOG_FILE_TO_CLEAR}" ]; then
            echo -e "## [Unreleased]\n\n### Added\n\n### Changed\n\n### Fixed\n\n### Removed\n" > "${CHANGELOG_FILE_TO_CLEAR}"
            echo "CHANGELOG.md wurde mit dem Template für das nächste Release überschrieben."
          
            git add "${CHANGELOG_FILE_TO_CLEAR}"
            if ! git diff --staged --quiet; then
              git commit -m "chore: Reset ${CHANGELOG_FILE_TO_CLEAR} for next release [skip ci]"
              git push origin "${TARGET_BRANCH}"
              echo "${CHANGELOG_FILE_TO_CLEAR} wurde geleert und die Änderung gepusht auf Branch ${TARGET_BRANCH}."
            else
              echo "${CHANGELOG_FILE_TO_CLEAR} wurde nicht geändert (war bereits im Template-Zustand)."
            fi
          else
            echo "FEHLER: ${CHANGELOG_FILE_TO_CLEAR} nicht gefunden, kann nicht geleert/zurückgesetzt werden."
          fi
