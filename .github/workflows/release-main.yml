# .github/workflows/release-main.yml
name: Release CI - Main (Manual Changelog, No Discord)

on:
  push:
    tags:
      - '*'

permissions:
  contents: write # Notwendig für Releases, Assets und das Committen der geleerten CHANGELOG.md

jobs:
  build_and_release:
    name: Build and Create GitHub Release
    runs-on: ubuntu-latest
    outputs:
      release_tag: ${{ github.ref_name }} # Output, falls er anderweitig benötigt wird

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Volle Historie für robuste Git-Operationen (z.B. Branch-Ermittlung)
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up JDK 24
        uses: actions/setup-java@v4
        with:
          java-version: '24'
          distribution: 'temurin'
          cache: maven

      - name: Build with Maven
        run: mvn -B package --file pom.xml

      - name: Prepare Changelog File for jDeploy
        id: prep_changelog_for_jdeploy
        run: |
          CHANGELOG_SOURCE_FILE="CHANGELOG.md"
          JDEPLOY_NOTES_DIR=".jdeploy"
          JDEPLOY_NOTES_FILE="${JDEPLOY_NOTES_DIR}/release-notes.md"
          
          echo "Prüfe, ob ${CHANGELOG_SOURCE_FILE} existiert..."
          if [ ! -f "${CHANGELOG_SOURCE_FILE}" ]; then
            echo "WARNUNG: ${CHANGELOG_SOURCE_FILE} nicht im Repository-Root gefunden!"
            echo "Erstelle eine Fallback-Datei für jDeploy: ${JDEPLOY_NOTES_FILE}"
            mkdir -p "${JDEPLOY_NOTES_DIR}"
            echo -e "### Changelog für ${{ github.ref_name }}\n\n*${CHANGELOG_SOURCE_FILE} nicht im Repository gefunden. Release wurde ohne benutzerdefinierte Notizen erstellt.*" > "${JDEPLOY_NOTES_FILE}"
          else
            echo "Verwende ${CHANGELOG_SOURCE_FILE} für Release Notes und kopiere nach ${JDEPLOY_NOTES_FILE}."
            mkdir -p "${JDEPLOY_NOTES_DIR}"
            cp "${CHANGELOG_SOURCE_FILE}" "${JDEPLOY_NOTES_FILE}"
            echo "--- Inhalt von ${JDEPLOY_NOTES_FILE} (vor jDeploy) ---"
            cat "${JDEPLOY_NOTES_FILE}"
            echo "-------------------------------------------------------"
          fi

      - name: Build App Installer Bundles and Create/Update GitHub Release (jDeploy)
        id: jdeploy_release
        uses: shannah/jdeploy@master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          # jDeploy sollte nun automatisch die ./.jdeploy/release-notes.md verwenden
          # und seine eigenen Installer-Informationen darunter anfügen.

      - name: Wait for jDeploy Release to be fully available
        run: |
          echo "Warte 20 Sekunden, um sicherzustellen, dass die Release-API-Daten konsistent sind..."
          sleep 20

      - name: Attach original CHANGELOG.md as Release Asset
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_NAME: ${{ github.ref_name }}
        run: |
          if [ -f "CHANGELOG.md" ]; then
            echo "Versuche, CHANGELOG.md an Release ${TAG_NAME} anzuhängen..."
            gh release upload "${TAG_NAME}" CHANGELOG.md --clobber
            echo "CHANGELOG.md wurde als Asset an die Release ${TAG_NAME} angehängt."
          else
            echo "CHANGELOG.md nicht gefunden, konnte nicht als Asset angehängt werden."
          fi

      # Der Schritt "Verify Final Release Body" ist für die Kernfunktionalität nicht mehr zwingend,
      # kann aber zu Debugging-Zwecken beibehalten oder auskommentiert werden.
      - name: Verify Final Release Body (Optional)
        id: verify_final_release_body
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "VERIFIZIERE finalen Release Body Inhalt:"
          VERIFIED_BODY=$(gh release view "${{ github.ref_name }}" --json body -q .body || echo "VERIFIZIERUNGSFEHLER")
          if [[ "${VERIFIED_BODY}" == "VERIFIZIERUNGSFEHLER" ]] || [ -z "$(echo -e "${VERIFIED_BODY}" | tr -d '[:space:]')" ]; then
            echo "WARNUNG: Finaler Release Body erscheint LEER oder nur Whitespace!"
          else
            echo "ERFOLG: Finaler Release Body ist NICHT leer. Inhalt:"
            echo "------------------- VERIFIZIERTER FINALER BODY START -------------------"
            echo -e "${VERIFIED_BODY}"
            echo "-------------------- VERIFIZIERTER FINALER BODY ENDE --------------------"
          fi

      - name: Clear and Commit CHANGELOG.md for next release
        if: always() # Sollte immer laufen, um den Changelog für den nächsten Release vorzubereiten
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          TARGET_BRANCH="${DEFAULT_BRANCH}"
          if [ -z "$TARGET_BRANCH" ]; then
            echo "Warnung: Default-Branch konnte nicht automatisch bestimmt werden. Verwende 'main' als Fallback."
            TARGET_BRANCH="main" # Sicherstellen, dass hier ein gültiger Branch steht (z.B. main oder master)
          fi
          echo "Zielbranch für das Leeren des Changelogs: ${TARGET_BRANCH}"
          
          # Stelle sicher, dass wir auf dem Zielbranch sind und er aktuell ist.
          # Wenn der aktuelle Commit (des Tags) nicht auf dem Default-Branch ist,
          # wird dieser Schritt fehlschlagen oder unerwartetes Verhalten zeigen.
          # Es wird angenommen, dass Tags auf dem Default-Branch erstellt werden.
          if ! git show-ref --verify --quiet "refs/heads/${TARGET_BRANCH}"; then
            echo "Lokaler Branch ${TARGET_BRANCH} existiert nicht. Versuche Remote-Branch zu holen."
            git fetch origin "${TARGET_BRANCH}:${TARGET_BRANCH}"
          fi
          git checkout "${TARGET_BRANCH}"
          git pull origin "${TARGET_BRANCH}" --ff-only
          
          CHANGELOG_FILE_TO_CLEAR="CHANGELOG.md"
          if [ -f "${CHANGELOG_FILE_TO_CLEAR}" ]; then
            echo -e "## --- Changelog ---\n\n### -- Added --\n\n### -- Changed --\n\n### -- Fixed --\n\n### -- Removed --\n" > "${CHANGELOG_FILE_TO_CLEAR}"
            echo "CHANGELOG.md wurde mit dem Template für das nächste Release überschrieben."
          
            git add "${CHANGELOG_FILE_TO_CLEAR}"
            if ! git diff --staged --quiet; then
              git commit -m "chore: Reset ${CHANGELOG_FILE_TO_CLEAR} for next release [skip ci]"
              git push origin "${TARGET_BRANCH}"
              echo "${CHANGELOG_FILE_TO_CLEAR} wurde geleert und die Änderung gepusht auf Branch ${TARGET_BRANCH}."
            else
              echo "${CHANGELOG_FILE_TO_CLEAR} wurde nicht geändert (war bereits im Template-Zustand)."
            fi
          else
            echo "FEHLER: ${CHANGELOG_FILE_TO_CLEAR} nicht gefunden, kann nicht geleert/zurückgesetzt werden."
          fi
